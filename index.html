<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>K8s AI Operations Center</title>
    <!-- Modern Theme -->
    <link rel="stylesheet" href="modern-theme.css?v=2">
    <!-- vis-network for interactive topology graphs -->
    <script type="text/javascript" src="https://unpkg.com/vis-network@9.1.9/standalone/umd/vis-network.min.js"></script>
    <style>
        /* Page-specific overrides for modern theme */
        body {
            padding: 16px;
            height: 100vh;
            overflow: hidden;
        }
        
    <style>
        /* Page-specific layout */
        .container {
            height: calc(100vh - 32px);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        /* Header Bar */
        .top-bar {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 12px;
        }
        
        .header h1 {
            font-size: 22px;
            color: var(--text-secondary);
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .header p {
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .header-badges {
            display: flex;
            gap: 8px;
            margin-top: 6px;
        }
        
        /* Stats Panel */
        .stats {
            width: 280px;
        }
        
        .stats h2 {
            font-size: 12px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-grid {
            display: flex;
            gap: 8px;
        }
        
        .stat-item {
            flex: 1;
            text-align: center;
            padding: 12px 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            border: 1.5px solid var(--border-color);
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: var(--accent-cyan);
            display: block;
            font-family: var(--font-mono);
        }
        
        .stat-label {
            font-size: 10px;
            color: var(--text-muted);
            margin-top: 4px;
            display: block;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        /* Foundry Controls */
        .foundry {
            width: 220px;
        }
        
        .foundry h2 {
            font-size: 12px;
            margin-bottom: 10px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .foundry-status {
            padding: 8px;
            border-radius: var(--radius-md);
            background: var(--bg-secondary);
            margin-bottom: 8px;
            font-size: 11px;
            color: var(--text-secondary);
            border: 1.5px solid var(--border-color);
            text-align: center;
            font-weight: 600;
        }
        
        .foundry-status.running {
            background: rgba(0, 255, 136, 0.1);
            color: var(--accent-success);
            border-color: var(--accent-success);
        }
        
        .foundry-status.stopped {
            background: rgba(255, 68, 68, 0.1);
            color: var(--accent-error);
            border-color: var(--accent-error);
        }
        
        .model-select {
            width: 100%;
            padding: 8px;
            margin-bottom: 8px;
        }
        
        .control-button {
            width: 100%;
            padding: 8px;
            font-size: 11px;
            font-weight: 600;
            margin-bottom: 6px;
        }
        
        .control-button.start {
            background: var(--accent-success);
            color: var(--bg-primary);
        }
        
        .control-button.stop {
            background: var(--accent-error);
            color: white;
        }
        
        .control-button.restart {
            background: var(--accent-warning);
            color: var(--bg-primary);
        }
        
        /* Quick Actions */
        .quick-actions {
            background: var(--bg-tertiary);
            border: 1.5px solid var(--border-color);
            border-radius: var(--radius-md);
            padding: 12px;
        }
        
        .quick-actions h2 {
            margin: 0;
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 8px;
        }
        
        .action-button {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1.5px solid var(--border-color);
            padding: 10px 14px;
            border-radius: var(--radius-md);
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all var(--transition-fast);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .action-button:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-cyan);
            transform: translateY(-1px);
        }
        
        /* AKS Arc Panel */
        .aksarc-panel {
            margin-top: 12px;
        }
        
        .aksarc-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }
        
        .aksarc-header h2 {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .diagnostic-button {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }
        
        .aksarc-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .info-item {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            border: 1.5px solid var(--border-color);
        }
        
        .info-label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 600;
        }
        
        .info-value {
            font-size: 11px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
        }
        
        /* Prompt Cards */
        .prompts-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
        }
        
        .prompt-card {
            background: var(--bg-tertiary);
            border: 1.5px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px;
            border-radius: var(--radius-md);
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: left;
            height: 80px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        .prompt-card:hover {
            background: var(--bg-elevated);
            border-color: var(--accent-cyan);
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }
        
        .prompt-card h3 {
            font-size: 12px;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .prompt-card p {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.4;
        }
        
        /* Chat Section */
        .chat-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .chat-container {
            background: var(--bg-tertiary);
            border: 1.5px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 16px;
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        
        .chat-header {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 600;
            padding-bottom: 12px;
            border-bottom: 1.5px solid var(--border-color);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px 0;
            min-height: 0;
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-muted);
        }
        
        .empty-state-icon {
            font-size: 48px;
            margin-bottom: 12px;
            opacity: 0.3;
        }
        
        .empty-state-text {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-secondary);
        }
        
        .empty-state-subtext {
            font-size: 11px;
            margin-top: 6px;
            color: var(--text-muted);
        }
        
        /* Messages */
        .message {
            margin-bottom: 14px;
            padding: 12px 14px;
            border-radius: var(--radius-md);
            max-width: 85%;
        }
        
        .message.user {
            background: var(--accent-cyan);
            color: var(--bg-primary);
            margin-left: auto;
            font-weight: 500;
        }
        
        .message.assistant {
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }
        
        .message-content {
            font-size: 13px;
            line-height: 1.6;
        }
        
        /* Chat Input */
        .chat-input {
            padding-top: 12px;
            border-top: 1px solid var(--border-color);
        }
        
        .input-group {
            display: flex;
            gap: 10px;
        }
        
        .input-group input {
            flex: 1;
            padding: 10px 14px;
            background: var(--bg-elevated);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-full);
            font-size: 13px;
        }
        
        .input-group input:focus {
            border-color: var(--accent-cyan);
        }
        
        .input-group input::placeholder {
            color: var(--text-muted);
        }
        
        .send-button {
            padding: 10px 20px;
            background: var(--accent-cyan);
            color: var(--bg-primary);
            font-weight: 600;
        }
        
        /* Modal */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            backdrop-filter: blur(4px);
        }
        
        .modal-content {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-lg);
            width: 90%;
            max-width: 1400px;
            height: 85vh;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 18px 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .modal-header h2 {
            font-size: 18px;
            color: var(--text-primary);
            margin: 0;
        }
        
        .close-button {
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 20px;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition-fast);
        }
        
        .close-button:hover {
            background: var(--accent-error);
            color: white;
            border-color: var(--accent-error);
        }
        
        /* Topology */
        .topology-container {
            flex: 1;
            overflow: auto;
            padding: 0;
            position: relative;
            background: var(--bg-primary);
        }
        
        .topology-loading {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-secondary);
            font-size: 16px;
        }
        
        #networkGraph {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
        }
        
        /* View Mode Selector */
        .view-mode-selector {
            display: flex;
            gap: 4px;
            background: var(--bg-elevated);
            border-radius: var(--radius-md);
            padding: 4px;
        }
        
        .view-mode-btn {
            padding: 8px 14px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            cursor: pointer;
            border-radius: var(--radius-sm);
            font-size: 12px;
            font-weight: 600;
            transition: all var(--transition-fast);
        }
        
        .view-mode-btn:hover {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .view-mode-btn.active {
            background: var(--accent-cyan);
            color: var(--bg-primary);
        }
        
        /* Dropdown Menu */
        .dropdown {
            position: relative;
        }
        
        .dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: var(--bg-elevated);
            border: 1px solid var(--border-color);
            border-radius: var(--radius-md);
            box-shadow: var(--shadow-lg);
            min-width: 200px;
            z-index: 1000;
        }
        
        .dropdown-menu button {
            width: 100%;
            padding: 12px 16px;
            border: none;
            background: transparent;
            color: var(--text-primary);
            text-align: left;
            cursor: pointer;
            font-size: 13px;
            transition: background var(--transition-fast);
        }
        
        .dropdown-menu button:hover {
            background: var(--bg-tertiary);
        }
        
        /* Architecture View */
        #architectureView {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 40px;
        }
        
        .arch-layer {
            margin-bottom: 40px;
        }
        
        .arch-layer-title {
            text-align: center;
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-cyan);
            margin-bottom: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .arch-nodes {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            flex-wrap: wrap;
        }
        
        .arch-node {
            background: var(--bg-tertiary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-lg);
            padding: 24px;
            min-width: 200px;
            text-align: center;
            box-shadow: var(--shadow-md);
            transition: all var(--transition-base);
        }
        
        .arch-node:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
            border-color: var(--accent-cyan);
        }
        
        .arch-node-icon {
            font-size: 40px;
            margin-bottom: 14px;
        }
        
        .arch-node-name {
            font-size: 15px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 10px;
        }
        
        .arch-node-details {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.6;
        }
        
        .arch-connector {
            text-align: center;
            color: var(--accent-cyan);
            font-size: 28px;
            margin: 24px 0;
        }
        
        /* List View */
        #listView {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 24px;
        }
        
        .topology-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 20px;
        }
        
        .topology-section {
            background: var(--bg-elevated);
            border-radius: var(--radius-md);
            padding: 18px;
            border: 1.5px solid var(--border-color);
        }
        
        .topology-section h3 {
            color: var(--text-secondary);
            margin-bottom: 14px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .topology-item {
            background: var(--bg-tertiary);
            padding: 10px 14px;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            border-left: 3px solid var(--accent-cyan);
        }
        
        .topology-item-name {
            font-weight: 600;
            color: var(--text-primary);
            font-size: 13px;
        }
        
        .topology-item-details {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .topology-pod {
            border-left-color: var(--accent-success);
        }
        
        .topology-node {
            border-left-color: var(--accent-warning);
        }
        
        .topology-namespace {
            border-left-color: var(--accent-cyan);
        }
        
        /* Enhanced Topology */
        .topology-summary {
            display: flex;
            gap: 14px;
            margin-bottom: 24px;
            padding: 14px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        
        .summary-item {
            flex: 1;
            text-align: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .summary-item strong {
            display: block;
            font-size: 22px;
            color: var(--accent-cyan);
            margin-bottom: 4px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .communication-matrix {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .comm-flow {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            font-size: 12px;
            border: 1.5px solid var(--border-color);
        }
        
        .comm-source, .comm-target {
            padding: 6px 10px;
            background: var(--bg-elevated);
            border-radius: var(--radius-sm);
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }
        
        .comm-arrow {
            color: var(--accent-cyan);
            font-weight: bold;
        }
        
        .comm-details {
            margin-left: auto;
            padding: 3px 8px;
            background: var(--accent-cyan);
            color: var(--bg-primary);
            border-radius: var(--radius-full);
            font-size: 10px;
            font-weight: 600;
        }
        
        .dependency-card {
            background: var(--bg-secondary);
            padding: 14px;
            border-radius: var(--radius-md);
            margin-bottom: 12px;
            border-left: 3px solid var(--accent-cyan);
        }
        
        .dependency-card h4 {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .port-list {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        
        .port-badge {
            background: var(--bg-elevated);
            color: var(--accent-cyan);
            padding: 3px 8px;
            border-radius: var(--radius-sm);
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            border: 1.5px solid var(--border-color);
        }
        
        .ip-badge {
            background: var(--accent-success);
            color: white;
            padding: 3px 10px;
            border-radius: var(--radius-full);
            font-size: 11px;
            font-family: 'JetBrains Mono', monospace;
            display: inline-block;
            margin: 0 4px;
            font-weight: 600;
        }
        
        .target-pods {
            font-size: 11px;
            color: var(--text-secondary);
        }
        
        .warning-box {
            background: rgba(255, 184, 0, 0.1);
            border: 1.5px solid var(--accent-warning);
            border-radius: var(--radius-md);
            padding: 14px;
            margin-top: 12px;
            color: var(--accent-warning);
            font-size: 12px;
        }
        
        .connectivity-grid {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .connectivity-item {
            padding: 8px;
            background: var(--bg-secondary);
            border-radius: var(--radius-sm);
            font-size: 11px;
            color: var(--text-secondary);
            border: 1px solid var(--border-color);
        }
        
        .connectivity-item strong {
            color: var(--text-primary);
        }
        
        /* Diagnostic */
        .diagnostic-container {
            padding: 24px;
            overflow-y: auto;
            max-height: calc(85vh - 80px);
        }
        
        .diagnostic-summary {
            display: flex;
            gap: 14px;
            margin-bottom: 24px;
            padding: 14px;
            background: var(--bg-secondary);
            border-radius: var(--radius-md);
            border: 1px solid var(--border-color);
        }
        
        .summary-stat {
            flex: 1;
            text-align: center;
            font-size: 12px;
            color: var(--text-secondary);
        }
        
        .summary-stat strong {
            display: block;
            font-size: 28px;
            color: var(--accent-success);
            margin-bottom: 6px;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .summary-stat.error strong {
            color: var(--accent-error);
        }
        
        .diagnostic-results-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .diagnostic-result {
            background: var(--bg-secondary);
            padding: 14px;
            border-radius: var(--radius-md);
            border-left: 3px solid var(--accent-success);
        }
        
        .diagnostic-result.error {
            border-left-color: var(--accent-error);
        }
        
        .result-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        
        .result-message {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }
        
        .result-recommendation {
            font-size: 12px;
            color: var(--accent-warning);
            background: rgba(255, 184, 0, 0.1);
            padding: 8px;
            border-radius: var(--radius-sm);
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Top Bar: Header, Stats, Controls -->
        <div class="top-bar">
            <!-- Header -->
            <div class="card header">
                <h1>ü§ñ K8s AI Operations Center</h1>
                <p>Intelligent Kubernetes management and monitoring</p>
                <div class="header-badges">
                    <span class="badge badge-offline" id="statusBadge"><span class="status-dot offline"></span> Offline</span>
                    <span class="badge badge-info" id="platformBadge" style="display: none;"></span>
                </div>
            </div>
            
            <!-- Cluster Stats -->
            <div class="card stats">
                <h2>Cluster Stats</h2>
                <div class="stat-grid">
                    <div class="stat-item">
                        <span class="stat-value" id="podCount">-</span>
                        <span class="stat-label">Pods</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="nodeCount">-</span>
                        <span class="stat-label">Nodes</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-value" id="namespaceCount">-</span>
                        <span class="stat-label">Namespaces</span>
                    </div>
                </div>
            </div>
            
            <!-- Foundry Local Controls -->
            <div class="card foundry">
                <h2>Foundry Local Control</h2>
                <div id="foundryStatusText" class="foundry-status">Checking...</div>
                <div id="foundryHelp" style="font-size: 11px; color: var(--text-secondary); margin: 8px 0; display: none;">
                    üí° Select a model, then click Start
                </div>
                <select class="model-select btn-secondary" id="modelSelect" title="Select AI model to run" aria-label="Model selection">
                    <option value="">Loading models...</option>
                </select>
                <button class="control-button btn start" id="startBtn" onclick="startFoundry()">‚ñ∂Ô∏è Start</button>
                <button class="control-button btn stop" id="stopBtn" onclick="stopFoundry()" style="display:none;">‚èπÔ∏è Stop</button>
                <button class="control-button btn restart" id="restartBtn" onclick="restartFoundry()" style="display:none;">üîÑ Restart</button>
                <button class="btn btn-secondary" onclick="checkFoundryStatus()" style="font-size: 11px; padding: 6px 10px; margin-top: 4px; width: 100%;" title="Refresh model list">üîÑ Refresh</button>
            </div>
        </div>
        
        <!-- Quick Actions -->
        <div class="card quick-actions">
            <h2>‚ö° Quick Actions</h2>
            <div class="actions-grid">
                <button class="action-button" onclick="showAksArcDiagnostics()" title="Run cluster diagnostics and troubleshooting">
                    üîç Diagnostics
                </button>
                <button class="action-button" onclick="showTopology()" title="View cluster network topology">
                    üó∫Ô∏è Network Topology
                </button>
                <button class="action-button" onclick="askQuestion('Show me pod logs for the last hour')" title="Quick access to recent logs">
                    üìã Recent Logs
                </button>
                <button class="action-button" onclick="askQuestion('Check for any failing pods or errors')" title="Health check">
                    üè• Health Check
                </button>
            </div>
        </div>
        
        <!-- AKS Arc Info Panel (shown when AKS Arc detected) -->
        <div class="card aksarc-panel" id="aksarcPanel" style="display: none;">
            <div class="aksarc-header">
                <h2>‚òÅÔ∏è AKS Arc Cluster</h2>
                <button class="btn diagnostic-button" id="diagnosticsBtn" onclick="showAksArcDiagnostics()">üîç Run Diagnostics</button>
            </div>
            <div class="aksarc-info" id="aksarcInfo">
                <div class="info-item">
                    <span class="info-label">Cluster:</span>
                    <span class="info-value" id="clusterName">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Location:</span>
                    <span class="info-value" id="clusterLocation">-</span>
                </div>
                <div class="info-item">
                    <span class="info-label">Resource ID:</span>
                    <span class="info-value" id="clusterResourceId">-</span>
                </div>
            </div>
        </div>
        
        <!-- Quick Prompts -->
        <div class="prompts-row">
            <button class="prompt-card" onclick="askQuestion('Show me all running pods')">
                <h3>üöÄ Running Pods</h3>
                <p>View all active pods</p>
            </button>
            <button class="prompt-card" onclick="askQuestion('Check cluster health and control plane status')">
                <h3>üíö Health Check</h3>
                <p>Control plane & nodes</p>
            </button>
            <button class="prompt-card" onclick="askQuestion('Show me recent pod restarts and failures')">
                <h3>üîÑ Restarts</h3>
                <p>Recent pod restarts</p>
            </button>
            <button class="prompt-card" onclick="askQuestion('Show node pool status and resource usage')">
                <h3>üñ•Ô∏è Node Pools</h3>
                <p>Node pool health</p>
            </button>
            <button class="prompt-card" onclick="askQuestion('Show me system pods and Arc agents')">
                <h3>‚öôÔ∏è System Pods</h3>
                <p>System & Arc agents</p>
            </button>
            <button class="prompt-card" onclick="askQuestion('Check for any warnings or issues')">
                <h3>‚ö†Ô∏è Diagnostics</h3>
                <p>Troubleshoot issues</p>
            </button>
            <button class="prompt-card" style="background: linear-gradient(135deg, #2a3f5f 0%, #1e2d3d 100%); border: 1.5px solid #00d4ff;" onclick="showTopology()">
                <h3>üó∫Ô∏è Topology</h3>
                <p>Network visualization</p>
            </button>
        </div>
        
        <!-- Topology Modal -->
        <div id="topologyModal" class="modal" style="display: none;">
            <div class="modal-content" style="max-width: 95vw; max-height: 95vh; width: 95vw; height: 95vh;">
                <div class="modal-header">
                    <h2>üó∫Ô∏è Cluster Network Topology</h2>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <!-- View Mode Switcher -->
                        <div class="view-mode-selector">
                            <button class="view-mode-btn active" data-mode="graph" onclick="switchTopologyView('graph')" title="Interactive Network Graph">
                                üï∏Ô∏è Graph
                            </button>
                            <button class="view-mode-btn" data-mode="architecture" onclick="switchTopologyView('architecture')" title="Architecture Diagram">
                                üèóÔ∏è Architecture
                            </button>
                            <button class="view-mode-btn" data-mode="list" onclick="switchTopologyView('list')" title="List View">
                                üìã List
                            </button>
                        </div>
                        <div style="border-left: 1px solid var(--border-color); height: 24px; margin: 0 4px;"></div>
                        <!-- Export Options -->
                        <div class="dropdown">
                            <button class="action-button" onclick="toggleExportMenu()" title="Export options">
                                üíæ Export ‚ñæ
                            </button>
                            <div id="exportMenu" class="dropdown-menu" style="display: none;">
                                <button onclick="exportTopologyAs('png')">üñºÔ∏è Export as PNG</button>
                                <button onclick="exportTopologyAs('svg')">üìê Export as SVG</button>
                                <button onclick="exportTopologyAs('json')">üìÑ Export as JSON</button>
                            </div>
                        </div>
                        <button class="close-button" onclick="closeTopology()">‚úï</button>
                    </div>
                </div>
                <div id="topologyView" class="topology-container">
                    <div class="topology-loading">Loading topology...</div>
                </div>
            </div>
        </div>
        
        <!-- Chat Section -->
        <div class="chat-section">
            <div class="chat-container card">
                <div class="chat-header">üí¨ Start a conversation</div>
                <div class="chat-messages" id="chatMessages">
                    <div class="empty-state">
                        <div class="empty-state-icon">üí¨</div>
                        <div class="empty-state-text">Start a conversation</div>
                        <div class="empty-state-subtext">Click a quick prompt or type your question below</div>
                    </div>
                </div>
                <div class="chat-input">
                    <div class="input-group">
                        <input type="text" id="userInput" placeholder="Ask about your cluster... (e.g., 'Show me all pods')" onkeypress="handleKeyPress(event)">
                        <button class="send-button" onclick="sendMessage()">Send</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        console.log('üöÄ K8s AI Assistant v2.0 - Script loaded');
        
        const API_BASE = 'http://localhost:8080/api';
        let conversationHistory = [];

        // Initialize
        async function init() {
            console.log('üîÑ Initializing application...');
            await detectPlatform();
            await updateClusterStats();
            await checkFoundryStatus();
            
            // Refresh every 30 seconds
            setInterval(() => {
                updateClusterStats();
                checkFoundryStatus();
            }, 30000);
            
            console.log('‚úÖ Initialization complete');
        }
        
        // Detect Kubernetes platform
        async function detectPlatform() {
            try {
                const response = await fetch(`${API_BASE}/platform/detect`);
                const data = await response.json();
                
                console.log('Platform detected:', data);
                
                const badge = document.getElementById('platformBadge');
                const aksarcPanel = document.getElementById('aksarcPanel');
                
                if (data.type === 'aks-arc') {
                    badge.textContent = '‚òÅÔ∏è AKS Arc';
                    badge.className = 'platform-badge aks-arc';
                    badge.style.display = 'inline-flex';
                    
                    // Show AKS Arc panel
                    aksarcPanel.style.display = 'block';
                    document.getElementById('clusterName').textContent = data.name || 'Unknown';
                    document.getElementById('clusterLocation').textContent = data.location || 'N/A';
                    document.getElementById('clusterResourceId').textContent = data.resource_id || 'N/A';
                } else if (data.type === 'k3s') {
                    badge.textContent = 'üöÄ k3s';
                    badge.className = 'platform-badge k3s';
                    badge.style.display = 'inline-flex';
                    aksarcPanel.style.display = 'none';
                } else {
                    badge.textContent = '‚éà Kubernetes';
                    badge.className = 'platform-badge';
                    badge.style.display = 'inline-flex';
                    aksarcPanel.style.display = 'none';
                }
            } catch (error) {
                console.error('Error detecting platform:', error);
            }
        }

        // Update cluster statistics
        async function updateClusterStats() {
            try {
                const response = await fetch(`${API_BASE}/cluster/status`);
                const data = await response.json();
                
                // Extract counts from the actual data structure
                const podCount = data.pods ? data.pods.length : 0;
                const namespaces = data.pods ? [...new Set(data.pods.map(p => p.namespace))] : [];
                const nodes = data.pods ? [...new Set(data.pods.map(p => p.node))] : [];
                
                document.getElementById('podCount').textContent = podCount;
                document.getElementById('nodeCount').textContent = nodes.length;
                document.getElementById('namespaceCount').textContent = namespaces.length;
            } catch (error) {
                console.error('Error fetching cluster stats:', error);
                document.getElementById('podCount').textContent = '-';
                document.getElementById('nodeCount').textContent = '-';
                document.getElementById('namespaceCount').textContent = '-';
            }
        }

        // Check Foundry status
        async function checkFoundryStatus() {
            console.log('üîç Checking Foundry status...');
            try {
                const response = await fetch(`${API_BASE}/foundry/status`);
                const data = await response.json();
                
                console.log('üìä Foundry status response:', data);
                console.log('   - Installed:', data.installed);
                console.log('   - Running:', data.running);
                console.log('   - Available models count:', data.available_models?.length);
                
                const statusDiv = document.getElementById('foundryStatusText');
                const modelSelect = document.getElementById('modelSelect');
                const startBtn = document.getElementById('startBtn');
                const stopBtn = document.getElementById('stopBtn');
                const restartBtn = document.getElementById('restartBtn');
                const statusBadge = document.getElementById('statusBadge');
                
                if (!statusDiv || !modelSelect || !startBtn) {
                    console.error('‚ùå Required DOM elements not found!');
                    return;
                }
                
                if (!data.installed) {
                    statusDiv.textContent = '‚ùå Foundry not installed';
                    statusDiv.className = 'foundry-status stopped';
                    modelSelect.innerHTML = '<option value="">Not available</option>';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'none';
                    restartBtn.style.display = 'none';
                    statusBadge.innerHTML = '<span class="status-dot offline"></span> Offline';
                    statusBadge.className = 'badge badge-offline';
                } else if (data.running) {
                    statusDiv.textContent = `üü¢ Running: ${data.model || 'active'}`;
                    statusDiv.className = 'foundry-status running';
                    statusBadge.innerHTML = '<span class="status-dot online"></span> Online';
                    statusBadge.className = 'badge badge-online';
                    startBtn.style.display = 'none';
                    stopBtn.style.display = 'block';
                    restartBtn.style.display = 'block';
                    
                    // Hide help text when running
                    const helpDiv = document.getElementById('foundryHelp');
                    if (helpDiv) helpDiv.style.display = 'none';
                    
                    // Replace dropdown with status display when running
                    if (data.model && modelSelect) {
                        modelSelect.innerHTML = `<option value="${data.model}" selected>‚ö° Currently Running: ${data.model}</option>`;
                        modelSelect.disabled = true;
                        modelSelect.style.color = '#10b981';
                        modelSelect.style.fontWeight = '600';
                    }
                    
                    // Populate models
                    if (data.available_models && data.available_models.length > 0) {
                        console.log('Populating', data.available_models.length, 'models');
                        
                        // Separate downloaded and not downloaded
                        const downloaded = data.available_models.filter(m => typeof m === 'object' && m.downloaded);
                        const notDownloaded = data.available_models.filter(m => typeof m === 'string' || !m.downloaded);
                        
                        let optionsHTML = '';
                        
                        if (downloaded.length > 0) {
                            optionsHTML += '<optgroup label="‚úÖ Ready to Use">';
                            downloaded.forEach(m => {
                                const modelName = m.name;
                                optionsHTML += `<option value="${modelName}">${modelName} ‚ö°</option>`;
                            });
                            optionsHTML += '</optgroup>';
                        }
                        
                        if (notDownloaded.length > 0) {
                            optionsHTML += '<optgroup label="üì¶ Will Download">';
                            notDownloaded.forEach(m => {
                                const modelName = typeof m === 'string' ? m : m.name;
                                optionsHTML += `<option value="${modelName}">${modelName} (download required)</option>`;
                            });
                            optionsHTML += '</optgroup>';
                        }
                        
                        modelSelect.innerHTML = optionsHTML;
                    }
                } else {
                    statusDiv.textContent = 'üî¥ Foundry not running';
                    statusDiv.className = 'foundry-status stopped';
                    statusBadge.innerHTML = '<span class="status-dot offline"></span> Offline';
                    statusBadge.className = 'badge badge-offline';
                    startBtn.style.display = 'block';
                    stopBtn.style.display = 'none';
                    restartBtn.style.display = 'none';
                    
                    // Re-enable dropdown when stopped
                    if (modelSelect) {
                        modelSelect.disabled = false;
                        modelSelect.style.color = '';
                        modelSelect.style.fontWeight = '';
                    }
                    
                    // Show help text
                    const helpDiv = document.getElementById('foundryHelp');
                    if (helpDiv) helpDiv.style.display = 'block';
                    
                    // Populate models
                    if (data.available_models && data.available_models.length > 0) {
                        console.log('Populating', data.available_models.length, 'models (not running)');
                        
                        // Separate downloaded and not downloaded models
                        const downloaded = data.available_models.filter(m => 
                            typeof m === 'object' && m.downloaded === true
                        );
                        const notDownloaded = data.available_models.filter(m => 
                            typeof m === 'string' || (typeof m === 'object' && m.downloaded !== true)
                        );
                        
                        console.log('Downloaded models:', downloaded.length);
                        console.log('Not downloaded:', notDownloaded.length);
                        if (downloaded.length > 0) {
                            console.log('‚úÖ Ready to use:', downloaded.map(m => m.name).join(', '));
                        }
                        
                        let options = '<option value="" disabled selected>üìã Select a model to start...</option>';
                        
                        if (downloaded.length > 0) {
                            options += '<optgroup label="‚úÖ Downloaded & Ready">';
                            downloaded.forEach(m => {
                                const size = m.size ? ` (${m.size})` : '';
                                options += `<option value="${m.name}">‚úÖ ${m.name}${size}</option>`;
                            });
                            options += '</optgroup>';
                        }
                        
                        if (notDownloaded.length > 0) {
                            options += '<optgroup label="üì¶ Available to Download">';
                            notDownloaded.forEach(m => {
                                const modelName = typeof m === 'string' ? m : m.name;
                                const size = typeof m === 'object' && m.size ? ` (${m.size})` : '';
                                options += `<option value="${modelName}">üì¶ ${modelName}${size}</option>`;
                            });
                            options += '</optgroup>';
                        }
                        
                        modelSelect.innerHTML = options;
                        startBtn.disabled = false;
                    } else {
                        console.log('No models found in response');
                        modelSelect.innerHTML = '<option value="">No models available</option>';
                        startBtn.disabled = true;
                        startBtn.title = 'No models available';
                        const helpDiv = document.getElementById('foundryHelp');
                        if (helpDiv) helpDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('‚ùå Error checking Foundry status:', error);
                const statusDiv = document.getElementById('foundryStatusText');
                const modelSelect = document.getElementById('modelSelect');
                if (statusDiv) {
                    statusDiv.textContent = '‚ö†Ô∏è Error checking status';
                    statusDiv.className = 'foundry-status stopped';
                }
                if (modelSelect) {
                    modelSelect.innerHTML = '<option value="">Error loading models</option>';
                }
            }
        }

        // Start Foundry
        async function startFoundry() {
            const modelSelect = document.getElementById('modelSelect');
            const model = modelSelect.value;
            
            if (!model || model === '') {
                showFoundryMessage('Please select a model first', 'error');
                modelSelect.focus();
                return;
            }
            
            // Disable button during startup
            const startBtn = document.getElementById('startBtn');
            startBtn.disabled = true;
            startBtn.textContent = '‚è≥ Starting...';
            
            try {
                const response = await fetch(`${API_BASE}/foundry/start?model=${model}`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    // Just refresh status - no alert popup
                    await checkFoundryStatus();
                } else {
                    // Show error in the foundry control area
                    showFoundryMessage(data.message, 'error');
                    startBtn.disabled = false;
                    startBtn.textContent = '‚ñ∂Ô∏è Start';
                }
            } catch (error) {
                showFoundryMessage(`Error: ${error.message}`, 'error');
                startBtn.disabled = false;
                startBtn.textContent = '‚ñ∂Ô∏è Start';
            }
        }

        // Show message in foundry control area
        function showFoundryMessage(message, type = 'info') {
            const foundryCard = document.querySelector('.foundry');
            let messageDiv = document.getElementById('foundryMessage');
            
            if (!messageDiv) {
                messageDiv = document.createElement('div');
                messageDiv.id = 'foundryMessage';
                messageDiv.style.cssText = `
                    margin-top: 8px;
                    padding: 8px;
                    border-radius: 4px;
                    font-size: 11px;
                    line-height: 1.4;
                `;
                foundryCard.appendChild(messageDiv);
            }
            
            // Set color based on type
            if (type === 'error') {
                messageDiv.style.background = 'rgba(239, 68, 68, 0.2)';
                messageDiv.style.border = '1px solid var(--accent-error)';
                messageDiv.style.color = 'var(--accent-error)';
            } else if (type === 'success') {
                messageDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                messageDiv.style.border = '1px solid var(--accent-success)';
                messageDiv.style.color = 'var(--accent-success)';
            } else {
                messageDiv.style.background = 'rgba(102, 126, 234, 0.2)';
                messageDiv.style.border = '1px solid var(--accent-primary)';
                messageDiv.style.color = 'var(--accent-primary)';
            }
            
            messageDiv.textContent = message;
            
            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (messageDiv) messageDiv.remove();
            }, 5000);
        }

        // Stop Foundry
        async function stopFoundry() {
            try {
                const response = await fetch(`${API_BASE}/foundry/stop`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    await checkFoundryStatus();
                } else {
                    showFoundryMessage(data.message, 'error');
                }
            } catch (error) {
                showFoundryMessage(`Error: ${error.message}`, 'error');
            }
        }

        // Restart Foundry
        async function restartFoundry() {
            const modelSelect = document.getElementById('modelSelect');
            const model = modelSelect.value;
            
            if (!model) {
                showFoundryMessage('Please select a model first', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/foundry/restart?model=${model}`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    await checkFoundryStatus();
                } else {
                    showFoundryMessage(data.message, 'error');
                }
            } catch (error) {
                showFoundryMessage(`Error: ${error.message}`, 'error');
            }
        }

        // Ask a question
        function askQuestion(question) {
            document.getElementById('userInput').value = question;
            sendMessage();
        }

        // Handle Enter key
        function handleKeyPress(event) {
            if (event.key === 'Enter') {
                sendMessage();
            }
        }

        // Send message
        async function sendMessage() {
            const input = document.getElementById('userInput');
            const question = input.value.trim();
            
            if (!question) return;
            
            input.value = '';
            
            // Add user message to chat
            addMessage('user', question);
            
            try {
                const response = await fetch(`${API_BASE}/chat/query`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ message: question })
                });
                
                const data = await response.json();
                
                // Add assistant response to chat (with markdown-style formatting)
                const answer = data.response || 'No response received';
                addMessage('assistant', answer);
                
            } catch (error) {
                addMessage('assistant', `Error: ${error.message}`);
            }
        }
        
        // Show topology visualization
        async function showTopology() {
            const modal = document.getElementById('topologyModal');
            const container = document.getElementById('topologyView');
            modal.style.display = 'flex';
            
            // Reset view mode
            window.currentTopologyView = 'graph';
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === 'graph');
            });
            
            try {
                const response = await fetch(`${API_BASE}/topology/analyze`);
                const data = await response.json();
                
                console.log('Topology data:', data);
                
                // Store for export and view switching
                window.topologyData = data;
                
                // Render initial view (graph)
                renderTopologyView('graph', container, data);
                
            } catch (error) {
                container.innerHTML = `<div style="color: var(--accent-error); text-align: center; padding: 40px; font-size: 16px;">Error loading topology: ${error.message}</div>`;
            }
        }
        
        // Switch between topology views
        function switchTopologyView(mode) {
            if (!window.topologyData) return;
            
            window.currentTopologyView = mode;
            
            // Update button states
            document.querySelectorAll('.view-mode-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.mode === mode);
            });
            
            const container = document.getElementById('topologyView');
            renderTopologyView(mode, container, window.topologyData);
        }
        
        // Render topology based on view mode
        function renderTopologyView(mode, container, data) {
            container.innerHTML = ''; // Clear previous content
            
            if (mode === 'graph') {
                renderNetworkGraph(container, data);
            } else if (mode === 'architecture') {
                renderArchitectureDiagram(container, data);
            } else if (mode === 'list') {
                renderListView(container, data);
            }
        }
        
        // Render interactive network graph using vis-network
        function renderNetworkGraph(container, data) {
            const pods = data.pods || [];
            const services = data.services || [];
            const dependencies = data.dependencies || [];
            const communicationMatrix = data.communication_matrix || [];
            
            // Create graph container
            const graphDiv = document.createElement('div');
            graphDiv.id = 'networkGraph';
            graphDiv.style.width = '100%';
            graphDiv.style.height = '100%';
            container.appendChild(graphDiv);
            
            // Build nodes and edges for vis-network
            const nodes = [];
            const edges = [];
            const nodeIds = new Set();
            
            // Add service nodes
            services.forEach((svc, idx) => {
                const nodeId = `svc-${svc.namespace}-${svc.name}`;
                if (!nodeIds.has(nodeId)) {
                    nodeIds.add(nodeId);
                    nodes.push({
                        id: nodeId,
                        label: `${svc.name}\\n(${svc.namespace})`,
                        title: `Service: ${svc.name}<br>Namespace: ${svc.namespace}<br>Cluster IP: ${svc.cluster_ip || 'N/A'}<br>Type: ${svc.type || 'ClusterIP'}`,
                        shape: 'box',
                        color: {
                            background: '#667eea',
                            border: '#5a67d8',
                            highlight: { background: '#7c3aed', border: '#6d28d9' }
                        },
                        font: { color: '#ffffff', size: 14, face: 'Arial', bold: true },
                        size: 25,
                        margin: 10
                    });
                }
            });
            
            // Add pod nodes
            pods.forEach((pod, idx) => {
                const nodeId = `pod-${pod.namespace}-${pod.name}`;
                if (!nodeIds.has(nodeId)) {
                    nodeIds.add(nodeId);
                    // Color coding: Green=Running, Orange=Pending, Blue=Succeeded, Red=Failed/Error
                    let statusColor = '#ef4444'; // Default red for errors
                    if (pod.status === 'Running') statusColor = '#10b981'; // Green
                    else if (pod.status === 'Pending') statusColor = '#f59e0b'; // Orange
                    else if (pod.status === 'Succeeded') statusColor = '#3b82f6'; // Blue for completed jobs
                    nodes.push({
                        id: nodeId,
                        label: pod.name,
                        title: `Pod: ${pod.name}<br>Namespace: ${pod.namespace}<br>IP: ${pod.ip || 'N/A'}<br>Status: ${pod.status}<br>Node: ${pod.node || 'N/A'}`,
                        shape: 'ellipse',
                        color: {
                            background: statusColor,
                            border: statusColor,
                            highlight: { background: '#065f46', border: '#064e3b' }
                        },
                        font: { color: '#ffffff', size: 12 },
                        size: 20
                    });
                }
            });
            
            // Add namespace nodes for better organization
            const namespaces = [...new Set([...services.map(s => s.namespace), ...pods.map(p => p.namespace)])];
            namespaces.forEach(ns => {
                const nodeId = `ns-${ns}`;
                if (!nodeIds.has(nodeId)) {
                    nodeIds.add(nodeId);
                    nodes.push({
                        id: nodeId,
                        label: `üì¶ ${ns}`,
                        title: `Namespace: ${ns}`,
                        shape: 'box',
                        color: {
                            background: '#2a2f45',
                            border: '#667eea',
                            highlight: { background: '#3a3f58', border: '#7c3aed' }
                        },
                        font: { color: '#e2e8f0', size: 16, bold: true },
                        size: 30,
                        borderWidth: 2,
                        margin: 15
                    });
                }
            });
            
            // Connect services to their namespace
            services.forEach(svc => {
                const svcId = `svc-${svc.namespace}-${svc.name}`;
                const nsId = `ns-${svc.namespace}`;
                edges.push({
                    from: nsId,
                    to: svcId,
                    arrows: { to: false },
                    color: { color: '#64748b', opacity: 0.3 },
                    dashes: true,
                    width: 1
                });
            });
            
            // Connect pods to their namespace
            pods.forEach(pod => {
                const podId = `pod-${pod.namespace}-${pod.name}`;
                const nsId = `ns-${pod.namespace}`;
                edges.push({
                    from: nsId,
                    to: podId,
                    arrows: { to: false },
                    color: { color: '#64748b', opacity: 0.3 },
                    dashes: true,
                    width: 1
                });
            });
            
            // Add edges from dependencies
            dependencies.forEach(dep => {
                const svcId = `svc-${dep.namespace}-${dep.service}`;
                
                if (dep.target_pods && dep.target_pods.length > 0) {
                    dep.target_pods.forEach(podName => {
                        const podId = `pod-${dep.namespace}-${podName}`;
                        if (nodeIds.has(svcId) && nodeIds.has(podId)) {
                            edges.push({
                                from: svcId,
                                to: podId,
                                arrows: { to: { enabled: true, scaleFactor: 0.8 } },
                                color: { color: '#667eea', opacity: 0.8 },
                                width: 2,
                                smooth: { type: 'curvedCW', roundness: 0.2 },
                                title: dep.service_ports ? dep.service_ports.map(p => `${p.protocol}:${p.port}`).join(', ') : ''
                            });
                        }
                    });
                }
            });
            
            // Add edges from communication matrix
            communicationMatrix.forEach(comm => {
                const sourceId = `pod-${comm.source_namespace || 'default'}-${comm.source}`;
                const targetId = `pod-${comm.target_namespace || 'default'}-${comm.target}`;
                
                // Try to find matching pods
                const sourcePod = pods.find(p => p.name === comm.source);
                const targetPod = pods.find(p => p.name === comm.target);
                
                if (sourcePod && targetPod) {
                    const actualSourceId = `pod-${sourcePod.namespace}-${sourcePod.name}`;
                    const actualTargetId = `pod-${targetPod.namespace}-${targetPod.name}`;
                    
                    edges.push({
                        from: actualSourceId,
                        to: actualTargetId,
                        arrows: { to: { enabled: true, scaleFactor: 0.6 } },
                        color: { color: '#f59e0b', opacity: 0.7 },
                        width: 1.5,
                        dashes: [5, 5],
                        title: `${comm.protocol}:${comm.port}`,
                        smooth: { type: 'curvedCCW', roundness: 0.2 }
                    });
                }
            });
            
            // Create network
            const networkData = { nodes: nodes, edges: edges };
            const options = {
                nodes: {
                    borderWidth: 2,
                    shadow: { enabled: true, color: 'rgba(0,0,0,0.5)', size: 10, x: 2, y: 2 }
                },
                edges: {
                    shadow: { enabled: true, color: 'rgba(0,0,0,0.3)', size: 5, x: 1, y: 1 },
                    smooth: { enabled: true, type: 'continuous' }
                },
                physics: {
                    enabled: true,
                    stabilization: { iterations: 200 },
                    barnesHut: {
                        gravitationalConstant: -8000,
                        centralGravity: 0.3,
                        springLength: 150,
                        springConstant: 0.04,
                        damping: 0.09
                    }
                },
                interaction: {
                    hover: true,
                    tooltipDelay: 100,
                    navigationButtons: true,
                    keyboard: true,
                    zoomView: true,
                    dragView: true
                },
                layout: {
                    improvedLayout: true,
                    hierarchical: false
                }
            };
            
            window.topologyNetwork = new vis.Network(graphDiv, networkData, options);
            
            // Add legend
            const legend = document.createElement('div');
            legend.style.cssText = 'position: absolute; top: 20px; right: 20px; background: var(--bg-card); padding: 16px; border-radius: 8px; border: 1px solid var(--border-color); font-size: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 10;';
            legend.innerHTML = `
                <div style="font-weight: 700; margin-bottom: 12px; color: var(--accent-primary);">Legend</div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <div style="width: 20px; height: 20px; background: #2a2f45; border: 2px solid #667eea; border-radius: 4px;"></div>
                    <span>Namespace</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <div style="width: 20px; height: 20px; background: #667eea; border-radius: 4px;"></div>
                    <span>Service</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <div style="width: 20px; height: 20px; background: #10b981; border-radius: 50%;"></div>
                    <span>Pod (Running)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <div style="width: 20px; height: 20px; background: #f59e0b; border-radius: 50%;"></div>
                    <span>Pod (Pending)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                    <div style="width: 20px; height: 20px; background: #3b82f6; border-radius: 50%;"></div>
                    <span>Pod (Succeeded)</span>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div style="width: 20px; height: 20px; background: #ef4444; border-radius: 50%;"></div>
                    <span>Pod (Failed/Error)</span>
                </div>
                <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--border-color); color: var(--text-secondary); font-size: 11px;">
                    üí° Use mouse wheel to zoom<br>
                    üñ±Ô∏è Drag to pan<br>
                    üéØ Click nodes for details
                </div>
            `;
            container.appendChild(legend);
        }
        
        // Render architecture diagram view
        function renderArchitectureDiagram(container, data) {
            const pods = data.pods || [];
            const services = data.services || [];
            const namespaces = [...new Set([...services.map(s => s.namespace), ...pods.map(p => p.namespace)])];
            
            const archDiv = document.createElement('div');
            archDiv.id = 'architectureView';
            container.appendChild(archDiv);
            
            let html = '';
            
            // Group by namespace
            namespaces.forEach(ns => {
                const nsServices = services.filter(s => s.namespace === ns);
                const nsPods = pods.filter(p => p.namespace === ns);
                
                html += '<div class="arch-layer">';
                html += `<div class="arch-layer-title">üì¶ Namespace: ${ns}</div>`;
                
                // Services layer
                if (nsServices.length > 0) {
                    html += '<div class="arch-layer-title" style="font-size: 12px; margin-top: 20px;">üåê Services</div>';
                    html += '<div class="arch-nodes">';
                    nsServices.forEach(svc => {
                        html += '<div class="arch-node">';
                        html += '<div class="arch-node-icon">‚öôÔ∏è</div>';
                        html += `<div class="arch-node-name">${svc.name}</div>`;
                        html += '<div class="arch-node-details">';
                        html += `Type: ${svc.type || 'ClusterIP'}<br>`;
                        html += `Cluster IP: ${svc.cluster_ip || 'N/A'}<br>`;
                        if (svc.ports && svc.ports.length > 0) {
                            html += `Ports: ${svc.ports.map(p => `${p.port}:${p.target_port}`).join(', ')}`;
                        }
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                    
                    html += '<div class="arch-connector">‚¨áÔ∏è</div>';
                }
                
                // Pods layer
                if (nsPods.length > 0) {
                    html += '<div class="arch-layer-title" style="font-size: 12px;">üéØ Pods</div>';
                    html += '<div class="arch-nodes">';
                    nsPods.forEach(pod => {
                        const statusEmoji = pod.status === 'Running' ? '‚úÖ' : pod.status === 'Pending' ? '‚è≥' : '‚ùå';
                        html += '<div class="arch-node">';
                        html += `<div class="arch-node-icon">${statusEmoji}</div>`;
                        html += `<div class="arch-node-name">${pod.name}</div>`;
                        html += '<div class="arch-node-details">';
                        html += `Status: ${pod.status}<br>`;
                        html += `IP: ${pod.ip || 'N/A'}<br>`;
                        html += `Node: ${pod.node || 'N/A'}`;
                        html += '</div>';
                        html += '</div>';
                    });
                    html += '</div>';
                }
                
                html += '</div>';
            });
            
            if (html === '') {
                html = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No architecture data available</div>';
            }
            
            archDiv.innerHTML = html;
        }
        
        // Render list view (original enhanced view)
        function renderListView(container, data) {
            const listDiv = document.createElement('div');
            listDiv.id = 'listView';
            container.appendChild(listDiv);
            
            // Safe access with default empty arrays
            const pods = data.pods || [];
            const services = data.services || [];
            const dependencies = data.dependencies || [];
            const networkPolicies = data.network_policies || [];
            const communicationMatrix = data.communication_matrix || [];
            
            let html = '<div class="topology-summary">';
            html += `<div class="summary-item"><strong>${pods.length}</strong> Pods</div>`;
            html += `<div class="summary-item"><strong>${services.length}</strong> Services</div>`;
            html += `<div class="summary-item"><strong>${dependencies.length}</strong> Dependencies</div>`;
            html += `<div class="summary-item"><strong>${networkPolicies.length}</strong> Network Policies</div>`;
            html += '</div>';
            
            // Communication matrix
            if (communicationMatrix && communicationMatrix.length > 0) {
                html += '<div class="topology-section">';
                html += '<h3>üîó Service Communication Matrix</h3>';
                html += '<div class="communication-matrix">';
                
                communicationMatrix.forEach(comm => {
                    // Find pod IPs
                    const sourcePod = pods.find(p => p.name === comm.source);
                    const targetPod = pods.find(p => p.name === comm.target);
                    
                    html += '<div class="comm-flow">';
                    html += `<div class="comm-source">${comm.source}`;
                    if (sourcePod && sourcePod.ip) {
                        html += ` <span class="ip-badge" title="Pod IP">üìç ${sourcePod.ip}</span>`;
                    }
                    html += '</div>';
                    html += '<div class="comm-arrow">‚Üí</div>';
                    html += `<div class="comm-target">${comm.target}`;
                    if (targetPod && targetPod.ip) {
                        html += ` <span class="ip-badge" title="Pod IP">üìç ${targetPod.ip}</span>`;
                    }
                    html += '</div>';
                    html += `<div class="comm-details">${comm.protocol}:${comm.port}`;
                    if (comm.target_port) {
                        html += `‚Üí${comm.target_port}`;
                    }
                    html += '</div>';
                    html += '</div>';
                });
                
                html += '</div>';
                html += '</div>';
            }
            
            // Dependencies
            if (dependencies && dependencies.length > 0) {
                html += '<div class="topology-section">';
                html += '<h3>üéØ Service Dependencies</h3>';
                
                dependencies.forEach(dep => {
                    // Find service details
                    const service = services.find(s => s.name === dep.service && s.namespace === dep.namespace);
                    
                    html += '<div class="dependency-card">';
                    html += `<h4>${dep.service} (${dep.namespace})</h4>`;
                    
                    // Show service IPs
                    if (service) {
                        html += '<div class="service-ips" style="margin: 8px 0; font-size: 0.9em;">';
                        if (service.cluster_ip) {
                            html += `<span class="ip-badge" title="Cluster IP">üåê ${service.cluster_ip}</span> `;
                        }
                        if (service.external_ip && service.external_ip !== 'None') {
                            html += `<span class="ip-badge" title="External IP" style="background: #4a90e2; color: white;">üåç ${service.external_ip}</span>`;
                        }
                        html += '</div>';
                    }
                    
                    if (dep.service_ports && dep.service_ports.length > 0) {
                        html += '<div class="port-list">';
                        dep.service_ports.forEach(port => {
                            html += `<span class="port-badge">${port.protocol}:${port.port}‚Üí${port.target_port}</span>`;
                        });
                        html += '</div>';
                    }
                    
                    // Show target pods with IPs
                    if (dep.target_pods && dep.target_pods.length > 0) {
                        html += '<div class="target-pods" style="margin-top: 10px;">';
                        html += `<strong>Target Pods (${dep.target_pods.length}):</strong><br>`;
                        dep.target_pods.forEach(podName => {
                            const pod = pods.find(p => p.name === podName);
                            html += `<div style="margin: 4px 0; padding-left: 10px;">‚Üí ${podName}`;
                            if (pod && pod.ip) {
                                html += ` <span class="ip-badge" title="Pod IP">üìç ${pod.ip}</span>`;
                            }
                            html += '</div>';
                        });
                        html += '</div>';
                    } else {
                        html += `<div class="target-pods">‚Üí ${dep.target_pods ? dep.target_pods.length : 0} target pod(s)</div>`;
                    }
                    
                    html += '</div>';
                });
                
                html += '</div>';
            }
            
            // Network policies
            if (data.network_policy_analysis && data.network_policy_analysis.affected_pods) {
                html += '<div class="topology-section">';
                html += '<h3>üõ°Ô∏è Network Policy Coverage</h3>';
                html += `<p>${data.network_policy_analysis.affected_pods.length} pods affected by network policies</p>`;
                if (data.network_policy_analysis.unrestricted_namespaces && 
                    data.network_policy_analysis.unrestricted_namespaces.length > 0) {
                    html += '<div class="warning-box">';
                    html += '<strong>‚ö†Ô∏è Unrestricted Namespaces:</strong> ';
                    html += data.network_policy_analysis.unrestricted_namespaces.join(', ');
                    html += '</div>';
                }
                html += '</div>';
            }
            
            // Namespace connectivity
            if (data.namespace_connectivity) {
                html += '<div class="topology-section">';
                html += '<h3>üåê Namespace Connectivity</h3>';
                html += '<div class="connectivity-grid">';
                
                Object.entries(data.namespace_connectivity).forEach(([ns, info]) => {
                    const targets = info.can_access || [];
                    const policyStatus = info.has_policies ? 'üîí' : 'üîì';
                    html += '<div class="connectivity-item">';
                    html += `<strong>${policyStatus} ${ns}</strong> (${info.pod_count} pods) ‚Üí ${targets.join(', ')}`;
                    html += '</div>';
                });
                
                html += '</div>';
                html += '</div>';
            }
            
            listDiv.innerHTML = html;
        }
        
        // Close topology modal
        function closeTopology() {
            document.getElementById('topologyModal').style.display = 'none';
            // Clean up network if it exists
            if (window.topologyNetwork) {
                window.topologyNetwork.destroy();
                window.topologyNetwork = null;
            }
        }
        
        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }
        
        // Close export menu when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = event.target.closest('.dropdown');
            if (!dropdown) {
                const menus = document.querySelectorAll('.dropdown-menu');
                menus.forEach(menu => menu.style.display = 'none');
            }
        });
        
        // Export topology in different formats
        async function exportTopologyAs(format) {
            if (!window.topologyData) {
                alert('No topology data available to export');
                return;
            }
            
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0];
            
            if (format === 'json') {
                exportTopologyJSON(timestamp);
            } else if (format === 'png') {
                exportTopologyImage('png', timestamp);
            } else if (format === 'svg') {
                exportTopologyImage('svg', timestamp);
            }
            
            // Close the export menu
            document.getElementById('exportMenu').style.display = 'none';
        }
        
        // Export topology data to JSON file
        function exportTopologyJSON(timestamp) {
            const exportData = {
                exported_at: new Date().toISOString(),
                cluster_info: {
                    pods: window.topologyData.pods?.length || 0,
                    services: window.topologyData.services?.length || 0,
                    dependencies: window.topologyData.dependencies?.length || 0,
                    network_policies: window.topologyData.network_policies?.length || 0
                },
                topology: window.topologyData
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `topology-${timestamp}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            console.log(`Topology exported to topology-${timestamp}.json`);
        }
        
        // Export topology as image (PNG or SVG)
        function exportTopologyImage(format, timestamp) {
            if (!window.topologyNetwork && window.currentTopologyView !== 'graph') {
                alert('Image export is only available for Graph view. Please switch to Graph view first.');
                return;
            }
            
            if (!window.topologyNetwork) {
                alert('Graph not initialized. Please wait for the graph to load.');
                return;
            }
            
            try {
                // Get canvas from vis-network
                const canvas = document.querySelector('#networkGraph canvas');
                if (!canvas) {
                    alert('Unable to find graph canvas for export.');
                    return;
                }
                
                if (format === 'png') {
                    canvas.toBlob(function(blob) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `topology-${timestamp}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        console.log(`Topology exported to topology-${timestamp}.png`);
                    });
                } else if (format === 'svg') {
                    // For SVG, we need to create an SVG representation
                    // This is a simplified version - vis-network doesn't natively support SVG export
                    alert('SVG export is not fully supported yet. Please use PNG export instead.');
                }
            } catch (error) {
                console.error('Export error:', error);
                alert(`Failed to export: ${error.message}`);
            }
        }
        
        // Legacy export function (kept for backward compatibility)
        function exportTopology() {
            exportTopologyAs('json');
        }
        
        // Show AKS Arc diagnostics modal
        async function showAksArcDiagnostics() {
            const modal = document.createElement('div');
            modal.className = 'modal';
            modal.innerHTML = `
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>üîç Cluster Diagnostics</h2>
                        <button class="close-button" onclick="this.closest('.modal').remove()">‚úï</button>
                    </div>
                    <div class="diagnostic-container">
                        <div id="diagnosticResults">
                            <div class="topology-loading">
                                <div style="margin-bottom: 10px;">‚è≥ Initializing diagnostics...</div>
                                <div id="diagnosticProgress" style="font-size: 0.9em; color: #888;"></div>
                            </div>
                        </div>
                        <button class="diagnostic-button" onclick="runDiagnosticRemediation()" id="remediateBtn" style="display:none; margin-top: 12px;">
                            üîß Run Auto-Remediation
                        </button>
                    </div>
                </div>
            `;
            modal.style.display = 'flex';
            document.body.appendChild(modal);
            
            // Update progress
            const updateProgress = (msg) => {
                const progressDiv = document.getElementById('diagnosticProgress');
                if (progressDiv) progressDiv.textContent = msg;
            };
            
            // Check prerequisites first
            try {
                updateProgress('Step 1/3: Checking prerequisites...');
                const checkResp = await fetch(`${API_BASE}/aksarc/diagnostics/check`);
                const checkData = await checkResp.json();
                
                if (!checkData.support_module_available) {
                    updateProgress('Step 2/3: AKS Arc module not found, running basic diagnostics...');
                    
                    // Run basic K8s diagnostics instead
                    await runBasicDiagnostics();
                    return;
                }
                
                // Run AKS Arc diagnostics
                updateProgress('Step 2/3: Running AKS Arc diagnostics...');
                const diagResp = await fetch(`${API_BASE}/aksarc/diagnostics/run`);
                const diagData = await diagResp.json();
                
                updateProgress('Step 3/3: Rendering results...');
                renderDiagnosticResults(diagData);
                
            } catch (error) {
                console.error('Diagnostics error:', error);
                document.getElementById('diagnosticResults').innerHTML = `
                    <div class="warning-box" style="border-color: var(--accent-error);">
                        <p><strong>‚ùå Diagnostics Error</strong></p>
                        <p>${error.message}</p>
                        <p style="font-size: 0.9em; margin-top: 10px;">Tip: Check that the backend is running and kubectl is configured</p>
                        <button class="diagnostic-button" onclick="runBasicDiagnostics()">Run Basic Checks</button>
                    </div>
                `;
            }
        }
        
        // Run basic Kubernetes diagnostics (fallback when AKS Arc module unavailable)
        async function runBasicDiagnostics() {
            const resultsDiv = document.getElementById('diagnosticResults');
            
            try {
                // Run parallel checks
                const checks = [
                    { name: 'Cluster Connection', endpoint: '/cluster/status' },
                    { name: 'Pod Health', endpoint: '/cluster/pods' },
                    { name: 'Service Health', endpoint: '/topology' },
                    { name: 'Platform Detection', endpoint: '/platform/detect' }
                ];
                
                resultsDiv.innerHTML = '<div class="topology-loading">Running basic cluster checks...</div>';
                
                const results = await Promise.allSettled(
                    checks.map(async check => {
                        const resp = await fetch(`${API_BASE}${check.endpoint}`);
                        const data = await resp.json();
                        return { check, data, status: resp.ok };
                    })
                );
                
                let html = '<div class="diagnostic-summary">';
                const passed = results.filter(r => r.status === 'fulfilled' && r.value.status).length;
                const failed = results.length - passed;
                html += `<div class="summary-stat"><strong>${passed}</strong> Passed</div>`;
                html += `<div class="summary-stat error"><strong>${failed}</strong> Failed</div>`;
                html += `<div class="summary-stat"><strong>${results.length}</strong> Total</div>`;
                html += '</div>';
                
                html += '<div class="diagnostic-results-list">';
                results.forEach((result, idx) => {
                    const check = checks[idx];
                    if (result.status === 'fulfilled' && result.value.status) {
                        html += `
                            <div class="diagnostic-result success">
                                <div class="result-header">‚úÖ ${check.name}</div>
                                <div class="result-message">API endpoint responding normally</div>
                            </div>
                        `;
                    } else {
                        const error = result.reason?.message || 'Failed to connect';
                        html += `
                            <div class="diagnostic-result error">
                                <div class="result-header">‚ùå ${check.name}</div>
                                <div class="result-message">${error}</div>
                                <div class="result-recommendation">üí° Check kubectl configuration and cluster connectivity</div>
                            </div>
                        `;
                    }
                });
                
                // Add info about AKS Arc module
                html += `
                    <div class="diagnostic-result" style="background: rgba(59, 130, 246, 0.1); border-color: #3b82f6;">
                        <div class="result-header">‚ÑπÔ∏è AKS Arc Advanced Diagnostics</div>
                        <div class="result-message">Support.AksArc PowerShell module not installed</div>
                        <div class="result-recommendation">
                            For AKS Arc clusters, install the module for advanced diagnostics:
                            <button class="diagnostic-button" style="margin-top: 8px; font-size: 0.9em;" onclick="installDiagnosticTools()">Install AKS Arc Module</button>
                        </div>
                    </div>
                `;
                
                html += '</div>';
                resultsDiv.innerHTML = html;
                
            } catch (error) {
                resultsDiv.innerHTML = `
                    <div style="color: var(--accent-error);">
                        <p>‚ùå Error running diagnostics</p>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }
        
        // Install diagnostic tools
        async function installDiagnosticTools() {
            const resultsDiv = document.getElementById('diagnosticResults');
            resultsDiv.innerHTML = '<div class="topology-loading">Installing Support.AksArc module...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/aksarc/diagnostics/install`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    resultsDiv.innerHTML = `
                        <div style="color: var(--accent-success);">
                            <p>‚úÖ Module installed successfully!</p>
                            <button class="diagnostic-button" onclick="showAksArcDiagnostics()">Run Diagnostics</button>
                        </div>
                    `;
                } else {
                    resultsDiv.innerHTML = `<div style="color: var(--accent-error);">Installation failed: ${data.error}</div>`;
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div style="color: var(--accent-error);">Error: ${error.message}</div>`;
            }
        }
        
        // Render diagnostic results
        function renderDiagnosticResults(data) {
            const resultsDiv = document.getElementById('diagnosticResults');
            let html = '<div class="diagnostic-summary">';
            html += `<div class="summary-stat"><strong>${data.passed}</strong> Passed</div>`;
            html += `<div class="summary-stat error"><strong>${data.failed}</strong> Failed</div>`;
            html += `<div class="summary-stat"><strong>${data.total_tests}</strong> Total</div>`;
            html += '</div>';
            
            html += '<div class="diagnostic-results-list">';
            data.results.forEach(result => {
                const statusIcon = result.status === 'Passed' ? '‚úÖ' : '‚ùå';
                const statusClass = result.status === 'Passed' ? 'success' : 'error';
                
                html += `<div class="diagnostic-result ${statusClass}">`;
                html += `<div class="result-header">${statusIcon} ${result.test_name}</div>`;
                html += `<div class="result-message">${result.message}</div>`;
                if (result.recommendation) {
                    html += `<div class="result-recommendation">üí° ${result.recommendation}</div>`;
                }
                html += '</div>';
            });
            html += '</div>';
            
            resultsDiv.innerHTML = html;
            
            // Show remediate button if there are failures
            if (data.failed > 0) {
                document.getElementById('remediateBtn').style.display = 'block';
            }
        }
        
        // Run automatic remediation
        async function runDiagnosticRemediation() {
            const resultsDiv = document.getElementById('diagnosticResults');
            resultsDiv.innerHTML = '<div class="topology-loading">Running auto-remediation...</div>';
            
            try {
                const response = await fetch(`${API_BASE}/aksarc/diagnostics/remediate`, { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    resultsDiv.innerHTML = `
                        <div style="color: var(--accent-success);">
                            <p>‚úÖ Remediation completed!</p>
                            <p>${data.message}</p>
                            <button class="diagnostic-button" onclick="showAksArcDiagnostics()">Re-run Diagnostics</button>
                        </div>
                    `;
                } else {
                    resultsDiv.innerHTML = `<div style="color: var(--accent-error);">Remediation failed: ${data.error}</div>`;
                }
            } catch (error) {
                resultsDiv.innerHTML = `<div style="color: var(--accent-error);">Error: ${error.message}</div>`;
            }
        }


        // Add message to chat
        function addMessage(role, content) {
            const messagesDiv = document.getElementById('chatMessages');
            
            // Remove empty state if present
            const emptyState = messagesDiv.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Simple markdown-style formatting for Direct Mode responses
            let formattedContent = content
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')  // **bold**
                .replace(/^‚Ä¢ (.+)$/gm, '<div style="margin-left: 12px;">‚Ä¢ $1</div>')  // bullet points
                .replace(/\n/g, '<br>');  // line breaks
            
            contentDiv.innerHTML = formattedContent;
            
            messageDiv.appendChild(contentDiv);
            messagesDiv.appendChild(messageDiv);
            
            // Scroll to bottom
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // Start the application
        init();
    </script>
</body>
</html>

